<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Lab 8: Machine Learning – ESS 330</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../favicon.ico" rel="icon">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-dark-8ea72dc5fed832574809a9c94082fbbb.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-5b6eb65566b1f8a996f1287d789c0740.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark-c63d9198b28a859559c0f0cce9729cfa.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../csu-rams-logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">ESS 330</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../syllabus.html"> 
<span class="menu-text">Syllabus</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../schedule.html"> 
<span class="menu-text">Schedule</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../labs.html"> 
<span class="menu-text">Labs</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/mikejohnson51/csu-ess-330/"> <i class="bi bi-github" role="img" aria-label="ESS 330">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#the-whole-game-plan" id="toc-the-whole-game-plan" class="nav-link active" data-scroll-target="#the-whole-game-plan">The Whole Game Plan</a></li>
  <li><a href="#lab-set-up" id="toc-lab-set-up" class="nav-link" data-scroll-target="#lab-set-up">Lab Set Up</a>
  <ul class="collapse">
  <li><a href="#libraries" id="toc-libraries" class="nav-link" data-scroll-target="#libraries">Libraries</a></li>
  </ul></li>
  <li><a href="#data-importtidytransform" id="toc-data-importtidytransform" class="nav-link" data-scroll-target="#data-importtidytransform">Data Import/Tidy/Transform</a></li>
  <li><a href="#data-spliting" id="toc-data-spliting" class="nav-link" data-scroll-target="#data-spliting">Data Spliting</a></li>
  <li><a href="#feature-engineering" id="toc-feature-engineering" class="nav-link" data-scroll-target="#feature-engineering">Feature Engineering</a></li>
  <li><a href="#resampling-and-model-testing" id="toc-resampling-and-model-testing" class="nav-link" data-scroll-target="#resampling-and-model-testing">Resampling and Model Testing</a>
  <ul class="collapse">
  <li><a href="#build-resamples" id="toc-build-resamples" class="nav-link" data-scroll-target="#build-resamples">1. Build resamples</a></li>
  <li><a href="#build-3-candidate-models" id="toc-build-3-candidate-models" class="nav-link" data-scroll-target="#build-3-candidate-models">2. Build 3 Candidate Models</a></li>
  <li><a href="#test-the-models" id="toc-test-the-models" class="nav-link" data-scroll-target="#test-the-models">3. Test the models</a></li>
  <li><a href="#model-selection" id="toc-model-selection" class="nav-link" data-scroll-target="#model-selection">4. Model Selection</a></li>
  </ul></li>
  <li><a href="#model-tuning" id="toc-model-tuning" class="nav-link" data-scroll-target="#model-tuning">Model Tuning</a>
  <ul class="collapse">
  <li><a href="#build-a-model-for-your-chosen-specification." id="toc-build-a-model-for-your-chosen-specification." class="nav-link" data-scroll-target="#build-a-model-for-your-chosen-specification.">1. Build a model for your chosen specification.</a></li>
  <li><a href="#create-a-workflow" id="toc-create-a-workflow" class="nav-link" data-scroll-target="#create-a-workflow">2. Create a workflow</a></li>
  <li><a href="#check-the-tunable-values-ranges" id="toc-check-the-tunable-values-ranges" class="nav-link" data-scroll-target="#check-the-tunable-values-ranges">3. Check The Tunable Values / Ranges</a></li>
  <li><a href="#define-the-search-space" id="toc-define-the-search-space" class="nav-link" data-scroll-target="#define-the-search-space">4. Define the Search Space</a></li>
  <li><a href="#tune-the-model" id="toc-tune-the-model" class="nav-link" data-scroll-target="#tune-the-model">5. Tune the Model</a></li>
  <li><a href="#check-the-skill-of-the-tuned-model" id="toc-check-the-skill-of-the-tuned-model" class="nav-link" data-scroll-target="#check-the-skill-of-the-tuned-model">6. Check the skill of the tuned model</a></li>
  <li><a href="#finalize-your-model" id="toc-finalize-your-model" class="nav-link" data-scroll-target="#finalize-your-model">7. Finalize your model</a></li>
  </ul></li>
  <li><a href="#final-model-verification" id="toc-final-model-verification" class="nav-link" data-scroll-target="#final-model-verification">Final Model Verification</a></li>
  <li><a href="#building-a-map" id="toc-building-a-map" class="nav-link" data-scroll-target="#building-a-map">Building a Map!</a></li>
  <li><a href="#summary" id="toc-summary" class="nav-link" data-scroll-target="#summary">Summary</a></li>
  <li><a href="#rubric" id="toc-rubric" class="nav-link" data-scroll-target="#rubric">Rubric</a>
  <ul class="collapse">
  <li><a href="#total-150" id="toc-total-150" class="nav-link" data-scroll-target="#total-150"><strong>Total: 150</strong></a></li>
  </ul></li>
  <li><a href="#submission" id="toc-submission" class="nav-link" data-scroll-target="#submission">Submission</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
<script src="https://use.fontawesome.com/5235085b15.js"></script>

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Lab 8: Machine Learning</h1>
<p class="subtitle lead">The Whole Game Plan</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="the-whole-game-plan" class="level1">
<h1>The Whole Game Plan</h1>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="../slides/images/whole-game-final-performance.jpg" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
</div>
</div>
<p>In Unit 3, we have learned a lot about the Machine Learning process. We have learned about feature engineering, resampling, the different types of machine learning goals, the different types of models (and R engines), and how to evaluate the performance and tune a final model.</p>
<p>We have also learned about the importance of data splitting and how to use the <code>tidymodels</code> package to create a machine learning pipeline.</p>
<p>In this lab, we will put all of this knowledge together to create a complete machine learning pipeline for a regression problem.</p>
</section>
<section id="lab-set-up" class="level1">
<h1>Lab Set Up</h1>
<ol type="1">
<li>Open your existing lab 6 project</li>
<li>Create a new Quarto document called <code>hyperparameter-tuning.qmd</code> in the project folder (next to your lab6.qmd).</li>
<li>Start with the lab!</li>
</ol>
<section id="libraries" class="level2">
<h2 class="anchored" data-anchor-id="libraries">Libraries</h2>
<p>Lets return to the CAMELS dataset we have been working with in Lab 6. We will use this dataset to predict the <code>q_mean</code> variable using the other variables in the dataset.</p>
<ul class="task-list">
<li><label><input type="checkbox">Load the <code>tidyverse</code> and <code>tidymodels</code> packages</label></li>
</ul>
</section>
</section>
<section id="data-importtidytransform" class="level1">
<h1>Data Import/Tidy/Transform</h1>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="../slides/images/data-science-eda.png" class="img-fluid figure-img" style="width:80.0%"></p>
</figure>
</div>
</div>
</div>
<p>Your first job is to read in the data and clean it. This is the first step in any data science process in order to prepare the data for modeling and or analysis.</p>
<ul class="task-list">
<li><p><label><input type="checkbox">Read in the data using <code>map</code>, <code>read_delim()</code> and <code>powerjoin::power_full_join()</code>. If you need a refresher on this please refer to lab 6.</label></p></li>
<li><p><label><input type="checkbox">Clean the data using <code>dplyr</code>, EDA (<code>skimr</code>, <code>visdat</code>, <code>ggpubr</code>), and other means to ensure it is in a good form for modeling.</label></p></li>
<li><p><label><input type="checkbox">At the end of this lab you will need to make a map of your predictions so be sure not to loose the <code>gauge_lat</code> and <code>gauge_lon</code> columns.</label></p></li>
</ul>
</section>
<section id="data-spliting" class="level1">
<h1>Data Spliting</h1>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="../slides/images/whole-game-transparent-split.jpg" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
</div>
</div>
<p>Now that you have your data cleaned and in a good form, you are ready to split the data into a training and testing set.</p>
<ul class="task-list">
<li><label><input type="checkbox">Be sure to set a seed to ensure the random process is reproducable.</label></li>
<li><label><input type="checkbox">Use the <code>initial_split()</code> function from the <code>rsample</code> package to split the data. Use 80% of the data for training and 20% for testing.</label></li>
<li><label><input type="checkbox">Use the <code>training()</code> and <code>testing()</code> functions from the <code>rsample</code> package to extract the training and testing <code>data.frames</code>.</label></li>
</ul>
</section>
<section id="feature-engineering" class="level1">
<h1>Feature Engineering</h1>
<p>Not all data - even cleaned data - is primed for model input. In this class we have looked at recipes as a way of defining a preprocessor for our modeling efforts. Recipes are a way of defining a set of steps to be applied to the data anytime it is used. They require a formula and incremental steps to transform a dataset.</p>
<ul class="task-list">
<li><p><label><input type="checkbox">Use the <code>recipe()</code> function from the <code>recipes</code> package to create a recipe object. The formula should be based on how you want to predict q_mean and the data should be the training data. Remember to apply any data transformations you deem needed, and be sure not to transform the outcome variable directly in the recipe.</label></p></li>
<li><p><label><input type="checkbox">You should not use <code>gauge_lat</code> and <code>gauge_lon</code> in the recipe as predictors. You can use the <code>step_rm()</code> function to remove them from the recipe while ensureing they persist in any data passed throuhg fit_*.</label></p></li>
</ul>
</section>
<section id="resampling-and-model-testing" class="level1">
<h1>Resampling and Model Testing</h1>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="../slides/images/whole-game-transparent-resamples.jpg" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
</div>
</div>
<p>Your training data is now ready to be used for model training and you have a preprocessor that you can iterate over.</p>
<section id="build-resamples" class="level3">
<h3 class="anchored" data-anchor-id="build-resamples">1. Build resamples</h3>
<ul class="task-list">
<li><label><input type="checkbox">The first step is to resample the data using the <code>vfold_cv()</code> function to generate 10 k-fold samples for cross-validation. Remember Cross Validation is critical for model testing and evaluation.</label></li>
</ul>
</section>
<section id="build-3-candidate-models" class="level3">
<h3 class="anchored" data-anchor-id="build-3-candidate-models">2. Build 3 Candidate Models</h3>
<p>You will also define a set of models to test. A model is defined by a specification, an engine, and a mode. The specification defines the type of model and the engine defines the implementation of the model. In class we learned about a few classes of models including</p>
<pre><code> - Linear models
 - Logistic regression
 - Decision trees
 - Random forests
 - Boosted trees
 - Support vector machines
 - Neural networks</code></pre>
<ul class="task-list">
<li><label><input type="checkbox">Define 3 models that you feel have the best chance of performing well on the data. You can use any of the models we have learned about in class. You can also use any of the engines we have learned about in class. The below image is illustrative, not dictating the models to choose.</label></li>
</ul>
</section>
<section id="test-the-models" class="level3">
<h3 class="anchored" data-anchor-id="test-the-models">3. Test the models</h3>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="../slides/images/whole-game-transparent-select.jpg" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
</div>
</div>
<p>With your defined set of models, k-folds samples, and recipe you are ready to test the models.</p>
<ul class="task-list">
<li><p><label><input type="checkbox">Use the <code>workflow_set()</code> function to test your three models against the recipe. You will use the <code>workflow_map()</code> function to map the models to the recipe and resamples.</label></p></li>
<li><p><label><input type="checkbox">Once complete, use autoplot to visualize the results of the workflow set.</label></p></li>
</ul>
</section>
<section id="model-selection" class="level3">
<h3 class="anchored" data-anchor-id="model-selection">4. Model Selection</h3>
<ul class="task-list">
<li><p><label><input type="checkbox">Based on the visualized metrics, select a model that you think best performs. Describe the reason for your choice using the metrics.</label></p></li>
<li><p><label><input type="checkbox">Describe the model you selected. What is the model type, engine, and mode. Why do you think it is performing well for this problem?</label></p></li>
</ul>
</section>
</section>
<section id="model-tuning" class="level1">
<h1>Model Tuning</h1>
<p>OK! Now you have selected a base model to use. Now we are interested in tuning it to extract the maximum performance that we can from it. Remember that all models have hyderparameters that are used to refine the underlying algorithm (specification)</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="../slides/images/whole-game-final-fit.jpg" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
</div>
</div>
<section id="build-a-model-for-your-chosen-specification." class="level3">
<h3 class="anchored" data-anchor-id="build-a-model-for-your-chosen-specification.">1. Build a model for your chosen specification.</h3>
<p>Be sure to set the mode and engine as you did above but this time specify <u>at least 2 hyperparameters</u> to tune using the <code>tune()</code> function. These are set in the model specification and options can be found in the documentation for the model you are using.</p>
<ul class="task-list">
<li><label><input type="checkbox">Define a tunable model</label></li>
</ul>
</section>
<section id="create-a-workflow" class="level3">
<h3 class="anchored" data-anchor-id="create-a-workflow">2. Create a workflow</h3>
<p>Now create a workflow object for this tune-able model and the recipe you created above.</p>
<ul class="task-list">
<li><label><input type="checkbox">Create a workflow object using the <code>workflow()</code> that adds your recipe and tunable model.</label></li>
</ul>
</section>
<section id="check-the-tunable-values-ranges" class="level3">
<h3 class="anchored" data-anchor-id="check-the-tunable-values-ranges">3. Check The Tunable Values / Ranges</h3>
<p>In the above step, you created a workflow based on a model that has at least 2 tunable hyper parameters. Remember <code>tune()</code> is aware of the tunable parameters in the model specification and provides some basic defaults to tune across. We want to see what the range of those are!</p>
<p>To do this, we can use the <code>extract_parameter_set_dials()</code>to return a list of the tunable parameters and their ranges. The output of this function is a data.frame.</p>
<ul class="task-list">
<li><label><input type="checkbox">Use the <code>extract_parameter_set_dials(YOUR MODEL WORKFLOW)</code> and save it to an object named <code>dials</code>. Check the <code>dials$object</code> slot to see the tunable parameters and their ranges.</label></li>
</ul>
<ul class="task-list">
<li><label><input type="checkbox">Optionally, you could update these default ranges using <code>update</code>. But for this lab, we will stick with the defaults.</label></li>
</ul>
</section>
<section id="define-the-search-space" class="level3">
<h3 class="anchored" data-anchor-id="define-the-search-space">4. Define the Search Space</h3>
<p>OK, we now know the viable range of the hyperparameters we want to tune. The full range of these values is the complete search space in which the best options could live. Remember, there are two ways for our computer to search for the best combination:</p>
<ol type="1">
<li><strong>Grid Search</strong>: This is a brute force approach that tests a predefined set of combinations. If elected as the search process, we need to specify how the set of combinations is chosen. This can be versions of evenly spaced (regular), random, or space filling curve/design (SFC/SFD).</li>
<li><strong>Iterative</strong>: This is a more efficient approach that uses a set of algorithms to search the space. This is often more efficient than grid search, but can be less thorough.</li>
</ol>
<p>For this lab, lets use a grid search based on a “Latin Hypercube” SFD method. We can specify this by passing our above <code>dials</code> object to the <code>grid_latin_hypercube()</code> function. The only thing we need to specify is the <code>size</code> of the grid we want to evaluate. The larger the size, the more thorough the search, but the longer your computer will take. Lets set the size to 20 for this lab and save the outputs to an object called <code>my.grid</code>.</p>
<ul class="task-list">
<li><label><input type="checkbox">Create a SFD Grid Object with 25 predefined combinations.</label></li>
</ul>
</section>
<section id="tune-the-model" class="level3">
<h3 class="anchored" data-anchor-id="tune-the-model">5. Tune the Model</h3>
<p>OK! You now have a tunable model workflow (<code>wf_tune</code>), a set of k-fold resamples to test over (<code>folds</code>), and a grid of hyperparameters to search (<code>grid</code>). Now we can use the <code>tune_grid()</code> function to search the grid and evaluate the model performance using the code below. In this example, we are doing 2 additional things. Setting a set of metrics to compute and saving the predictions to a output tibble.</p>
<ul class="task-list">
<li><label><input type="checkbox">Run the below code making any changes your need based on how you named your objects.</label></li>
<li><label><input type="checkbox">Run autoplot() on the <code>model_params</code> object to visualize the results of the tuning process.</label></li>
<li><label><input type="checkbox">Describe what you see!</label></li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>model_params <span class="ot">&lt;-</span>  <span class="fu">tune_grid</span>(</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    wf_tune,</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">resamples =</span> folds,</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">grid =</span> my.grid,</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">metrics =</span> <span class="fu">metric_set</span>(rmse, rsq, mae),</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">control =</span> <span class="fu">control_grid</span>(<span class="at">save_pred =</span> <span class="cn">TRUE</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="fu">autoplot</span>(model_params)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="check-the-skill-of-the-tuned-model" class="level3">
<h3 class="anchored" data-anchor-id="check-the-skill-of-the-tuned-model">6. Check the skill of the tuned model</h3>
<p>Now that you have tuned the model under many combinations of hyperparameters, you can check the skill using the <code>collect_metrics()</code> function. This will return a tibble with the metrics for each combination of hyperparameters.</p>
<ul class="task-list">
<li><label><input type="checkbox">Use the <code>collect_metrics()</code> function to check the skill of the tuned model. Describe what you see, remember dplyr functions like arrange, slice_*, and filter will work on this tibble.</label></li>
</ul>
<p>You can also use the <code>show_best()</code> function to show the best performing model based on a metric of your choice. For example, if you want to see the best performing model based on the RMSE metric, you can use the following code:</p>
<ul class="task-list">
<li><p><label><input type="checkbox">Use the <code>show_best()</code> function to show the best performing model based on Mean Absolute Error.</label></p></li>
<li><p><label><input type="checkbox">Please interpret the results of the first row of <code>show_best()</code>. What do you see? What hyperparameter set is best for this model, based on MAE?</label></p></li>
</ul>
<p>A short cut for <code>show_best(..., n = 1)</code> is to use <code>select_best()</code>. This will return the best performing hyperparameter set based on the metric you choose.</p>
<ul class="task-list">
<li><label><input type="checkbox">Use the <code>select_best()</code> function to save the best performing hyperparameter set to an object called <code>hp_best</code>.</label></li>
</ul>
</section>
<section id="finalize-your-model" class="level3">
<h3 class="anchored" data-anchor-id="finalize-your-model">7. Finalize your model</h3>
<p>Fantastic, you now have a workflow and a idealized set of hyperparameters to use for your model. Now we can inject the hyperparameters into the workflow using the <code>finalize_workflow()</code> function. This will create a new workflow object that is no longer dependent on <code>tune()</code> attributes, but rather the finalized hyperparameters. This is a new workflow object that is ready to be used for final model fitting.</p>
<ul class="task-list">
<li><label><input type="checkbox">Run finalize_workflow() based on your workflow and best hyperparmater set to create a final workflow object.</label></li>
</ul>
</section>
</section>
<section id="final-model-verification" class="level1">
<h1>Final Model Verification</h1>
<p>The <code>show_best()</code>, <code>select_best()</code>, and <code>collect_metrics()</code> functions are all great, but they are only implemented on the resampled iterations of the training data. Remember, applications over just the training data can often be misleading. We need to check the final model on the test data to see how it performs.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="../slides/images/whole-game-final-performance.jpg" class="img-fluid figure-img" style="width:100.0%"></p>
</figure>
</div>
</div>
</div>
<p>Here, we can leverage a short cut in tidymodels to fit the final model to the test data. This is done using the <code>last_fit()</code> function. The <code>last_fit()</code> function will take the finalized workflow, and the full split data object (containing both the training and testing data) and fit it to the training data and validate it on the testing data.</p>
<ul class="task-list">
<li><label><input type="checkbox">Use <code>last_fit()</code> to fit the finalized workflow the original split object (output of <code>initial_split()</code>). This will fit the model to the training data and validate it on the testing data.</label></li>
</ul>
<p>With the final model fit, we can now check the performance of the model on the test data in our two standard ways!</p>
<ul class="task-list">
<li><label><input type="checkbox">Use the <code>collect_metrics()</code> function to check the performance of the final model on the test data. This will return a tibble with the metrics for the final model.</label></li>
</ul>
<ul class="task-list">
<li><p><label><input type="checkbox">Interpret these results. How does the final model perform on the test data? Is it better or worse than the training data? Use your knowledge of the regression based metrics to describe the results.</label></p></li>
<li><p><label><input type="checkbox">Use the <code>collect_predictions()</code> function to check the predictions of the final model on the test data. This will return a tibble with the predictions for the final model.</label></p></li>
<li><p><label><input type="checkbox">Use the output of this to create a scatter plot of the predicted values vs the actual values. Use the <code>ggplot2</code> package to create the plot. This plot should include (1) geom_smooth(method = “lm”) to add the linear fit of predictions and truth (2) <code>geom_abline()</code> to add a 1:1 line (3) nice colors via scale_color_* and (4) accurate labels.</label></p></li>
</ul>
</section>
<section id="building-a-map" class="level1">
<h1>Building a Map!</h1>
<p>As a last step, you want to map your predictions across CONUS. Return to the ggplot examples in Lab 6 to refresh your memory on building a map with a defined color pallete.</p>
<p>To build your final prediction, you can use fit() to fit the finalized workflow to the full, cleaned data (prior to splitting). This will return a fitted model object that can be used to make predictions on new data.</p>
<ul class="task-list">
<li><p><label><input type="checkbox">This full fit can be passed to the <code>augment()</code> function to make predictions on the full, cleaned data. This will return a tibble with the predictions for the full data.</label></p></li>
<li><p><label><input type="checkbox">Use the <code>mutate()</code> function to calculate the residuals of the predictions. The residuals are the difference between the predicted values and the actual values squared.</label></p></li>
<li><p><label><input type="checkbox">Use <code>ggplot2</code> to create a map of the predictions.</label></p></li>
<li><p><label><input type="checkbox">Use <code>ggplot2</code> to create a map of the residuals.</label></p></li>
<li><p><label><input type="checkbox">Use <code>patchwork</code> to combine the two maps into one figure.</label></p></li>
</ul>
</section>
<section id="summary" class="level1">
<h1>Summary</h1>
<p>And that’s it! You have implemented a complete, robust, and well tuned machine learning pipeline. You have learned how to read in data, clean it, split it, create a recipe, resample it, test models, tune models, and finally validate the model on the test data. This is <u>NOT</u> an insignificant amount of work and knowledge and I hope you are proud of how far you have come in this class.</p>
</section>
<section id="rubric" class="level1">
<h1>Rubric</h1>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Task</th>
<th>Subtask</th>
<th>(Sub)Points</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Data Import/Tidy/Transform</td>
<td></td>
<td><strong>20</strong></td>
</tr>
<tr class="even">
<td></td>
<td>Library Loading</td>
<td>5</td>
</tr>
<tr class="odd">
<td></td>
<td>Data Ingest</td>
<td>5</td>
</tr>
<tr class="even">
<td></td>
<td>Data Cleaning</td>
<td>10</td>
</tr>
<tr class="odd">
<td>Data Spiting</td>
<td></td>
<td><strong>10</strong></td>
</tr>
<tr class="even">
<td></td>
<td>Initial Split</td>
<td>5</td>
</tr>
<tr class="odd">
<td></td>
<td>Testing/Training</td>
<td>5</td>
</tr>
<tr class="even">
<td>Feature Engineering</td>
<td></td>
<td>10</td>
</tr>
<tr class="odd">
<td></td>
<td>Proper Recipe</td>
<td>10</td>
</tr>
<tr class="even">
<td>Data Resampling and Model Testing</td>
<td></td>
<td><strong>25</strong></td>
</tr>
<tr class="odd">
<td></td>
<td>Cross Validation Dataset (k-folds)</td>
<td>5</td>
</tr>
<tr class="even">
<td></td>
<td>Define Three Regression Models</td>
<td>10</td>
</tr>
<tr class="odd">
<td></td>
<td>Workflow Set/Map/Autoplot</td>
<td>5</td>
</tr>
<tr class="even">
<td></td>
<td>Model Selection with Justification</td>
<td>5</td>
</tr>
<tr class="odd">
<td>Model Tuning</td>
<td></td>
<td><strong>25</strong></td>
</tr>
<tr class="even">
<td></td>
<td>Tunable model setup</td>
<td>5</td>
</tr>
<tr class="odd">
<td></td>
<td>Tunable workflow defined</td>
<td>5</td>
</tr>
<tr class="even">
<td></td>
<td>Description of dial ranges</td>
<td>5</td>
</tr>
<tr class="odd">
<td></td>
<td>Defined Search Space</td>
<td>5</td>
</tr>
<tr class="even">
<td></td>
<td>Executed Tune Grid</td>
<td>5</td>
</tr>
<tr class="odd">
<td>Check the skill of the tuned model</td>
<td></td>
<td><strong>10</strong></td>
</tr>
<tr class="even">
<td></td>
<td>Collect Metrics/Show Best/Describe in Plain Language</td>
<td>10</td>
</tr>
<tr class="odd">
<td>Finalize your model</td>
<td></td>
<td><strong>5</strong></td>
</tr>
<tr class="even">
<td></td>
<td>Finalize Workflow</td>
<td>5</td>
</tr>
<tr class="odd">
<td>Final Model Verification</td>
<td></td>
<td><strong>25</strong></td>
</tr>
<tr class="even">
<td></td>
<td>Implement the last fit</td>
<td>5</td>
</tr>
<tr class="odd">
<td></td>
<td>Interpret Metrics</td>
<td>10</td>
</tr>
<tr class="even">
<td></td>
<td>Plot Predictions</td>
<td>10</td>
</tr>
<tr class="odd">
<td>Final Figure</td>
<td></td>
<td><strong>20</strong></td>
</tr>
<tr class="even">
<td></td>
<td>Augment Data &amp; Calculate Residuals</td>
<td>5</td>
</tr>
<tr class="odd">
<td></td>
<td>Map Predicted Q and Residuals</td>
<td>15</td>
</tr>
<tr class="even">
<td>Submission</td>
<td></td>
<td><strong>10</strong></td>
</tr>
<tr class="odd">
<td></td>
<td>Working URL</td>
<td>10</td>
</tr>
</tbody>
</table>
<section id="total-150" class="level3">
<h3 class="anchored" data-anchor-id="total-150"><strong>Total: 150</strong></h3>
</section>
</section>
<section id="submission" class="level1">
<h1>Submission</h1>
<p>Once you have completed the above steps, you can submit your lab for grading. The lab should be submitted as a URL to your deployed repo page. The repo should contain the qmd file with all the code, data, and output used in the lab.</p>


</section>

</main> <!-- /main -->
<script>
  Reveal.addEventListener( 'slidechanged', function( event ) {
    console.log("hello")
    
    slide_id = event.currentSlide.id
    link = "annotations" + ".html#" + slide_id
    
    var annotation_div = document.createElement('div')
    annotation_div.setAttribute("class", "annotation-link")
    
    var notes_link = document.createElement('a')
    notes_link.setAttribute("href", link)
    notes_link.setAttribute("target", "_blank")
    
    var iii = document.createElement('i')
    iii.setAttribute("class", "fa fa-info")
    notes_link.appendChild(iii)
    
    annotation_div.appendChild(notes_link)
    
    var tmp = event.currentTarget.getElementsByClassName("annotation-link")
    if (tmp.length === 1) {
      tmp[0].remove()
    }
    
    if (event.currentSlide.classList.contains("annotation")) {
      event.currentTarget.append(annotation_div)
    }
  } );

</script>
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>